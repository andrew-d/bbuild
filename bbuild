#!/usr/bin/env bash


set -e              # Abort when a command exists with a non-zero exit status
set -o pipefail     # Cause a pipeline to return the exit status of the last
                    # command that returned a non-zero return value.
set -u              # Attempting to use an undefined variable will print an
                    # error and exit the program.


######################################################################
# Global Variables
#
# This list contains a description of all global variables and what
# they mean.
#
#   +-----------------+---------------------------------------------+
#   |      NAME       | DESCRIPTION                                 |
#   +-----------------+---------------------------------------------+
#   | program         | The name of this script                     |
#   | program_version | The version of this script                  |
#   | base_dir        | Base directory for performing the build in  |
#   | cache_dir       | Directory used for storing cache of sources |
#   | recipe_dir      | Directory that contains our recipes         |
#   | source_dir      | Per-recipe directory that contains sources  |
#   +-----------------+---------------------------------------------+
#
######################################################################


# Global script information.
program=${0##*/}
program_version=0.0.1
declare -i verbosity=2

# Color definitions (start as 'on').
NORMAL="\033[1;0m"
##STRONG="\033[1;1m"
RED="\033[1;31m"
GREEN="\033[1;32m"
YELLOW="\033[1;33m"
BLUE="\033[1;34m"
MAGENTA="\033[1;35m"
WHITE="\033[1;37m"


######################################################################
# Enable / disable colors in the program.
#
# Globals:
#   None
#
# Arguments:
#   $1 = 'on' or 'off'
#
# Returns:
#   None
######################################################################
function set_colors() {
  case "$1" in
    on)
      NORMAL="\033[1;0m"
      ##STRONG="\033[1;1m"
      RED="\033[1;31m"
      GREEN="\033[1;32m"
      YELLOW="\033[1;33m"
      BLUE="\033[1;34m"
      MAGENTA="\033[1;35m"
      WHITE="\033[1;37m"
      ;;
    off)
      NORMAL=""
      ##STRONG=""
      RED=""
      GREEN=""
      YELLOW=""
      BLUE=""
      MAGENTA=""
      WHITE=""
      ;;
  esac
}


######################################################################
# Various helper log functions.
#
# Globals:
#   $verbosity = verboseness level
#
#   Note: verbosity levels
#       debug   = 1
#       info    = 2
#       warning = 3
#       error   = 4 (always printed)
#
# Arguments:
#   $1 = string
#
# Returns:
#   None
######################################################################
function debug() {
  [[ "$verbosity" -gt 1 ]] && return
  local prompt="${MAGENTA}==> DEBUG:${NORMAL}"
  printf "${prompt} ${WHITE}%s${NORMAL}\n" "$1" >&2
}

function info() {
  [[ "$verbosity" -gt 2 ]] && return
  local prompt="${GREEN}==>${NORMAL}"
  printf "${prompt} ${WHITE}%s${NORMAL}\n" "$1" >&2
}

function info2() {
  [[ "$verbosity" -gt 2 ]] && return
  local prompt="${BLUE}  ->${NORMAL}"
  printf "${prompt} ${WHITE}%s${NORMAL}\n" "$1" >&2
}

function warn() {
  [[ "$verbosity" -gt 3 ]] && return
  local prompt="${YELLOW}==> WARNING:${NORMAL}"
  printf "${prompt} ${WHITE}%s${NORMAL}\n" "$1" >&2
}

function error() {
  local prompt="${RED}==> ERROR:${NORMAL}"
  printf "${prompt} ${WHITE}%s${NORMAL}\n" "$1" >&2
}

function die() {
  error "$1"
  exit 1
}


######################################################################
# Fetches a given URL and saves it as the given file.
#
# Globals:
#   None
#
# Arguments:
#   $1 = url
#   $2 = target file
#
# Returns:
#   0 on success, 1 on failure
######################################################################
function fetch_url() {
  local url="$1"
  local target="$2"

  # TODO: options if verbose/not verbose
  # TODO: fall back to wget if curl not present
  curl -L -o "$target" "$url" || exit 1
  return 0
}


######################################################################
# Detects whether a given source is remote (i.e. whether the source
# is on the local filesystem or should be fetched from a remote
# location).
#
# Globals:
#   None
#
# Arguments:
#   $1 = source specification
#
# Returns:
#   0/true if the source is remote, 1/false if it is not
######################################################################
function is_remote() {
  local src="$1"

  case "${src#*::}" in
    http://*|ftp://*|https://*)
      return 0
      ;;
  esac

  return 1
}


######################################################################
# Gets the filename from a given source  If the source is prefixed
# with a 'filename::<url>', the 'filename' portion will be used
# instead of anything from the URL.
#
# Globals:
#   None
#
# Arguments:
#   $1 = source
#
# Returns:
#   0 always
#
# Stdout:
#   The filename from the given source
######################################################################
function filename_from_source() {
  local src="$1"

  # Get everything after the last slash.  Equivalent to $(basename $url).
  local filename="${src##*/}"

  # If there is a '::' in the source, we take everything before it.
  case "$src" in
    *::*) filename=${src%%::*};;
  esac

  # Output
  echo "$filename"
  return 0
}


######################################################################
# Gets the URL from a given source  If the source is prefixed with a
# 'filename::<url>', the 'filename' portion will be stripped.
#
# Globals:
#   None
#
# Arguments:
#   $1 = source
#
# Returns:
#   0 always
#
# Stdout:
#   The URL from the given source
######################################################################
function url_from_source() {
  local src="$1"
  local url="$src"

  # If there is a '::' in the source, we take everything after it.
  case "$src" in
    *::*) url=${src##*::};;
  esac

  # Output
  echo "$url"
  return 0
}


######################################################################
# Downloads all given sources into the specified target directory.
# Local file sources are symlinked into the target directory.
#
# Globals:
#   $recipe_dir = the recipe directory
#   $cache_dir  = the cache directory for downloaded sources
#
# Arguments:
#   $1 = target directory
#   $2 .. = sources
#
# Returns:
#   0 on success, 1 on failure
######################################################################
function default_fetch() {
  local target_dir="$1"
  shift

  declare -ar sources=("${@}")
  local filename url

  debug "Have ${#sources[@]} source(s) to fetch"

  # Avoid an 'unbound variable' array when a recipe has no sources.
  if [[ ${#sources[@]} -eq 0 ]]; then
    return 0
  fi

  for s in "${sources[@]}"; do
    info "Fetching source: $s"
    filename=$(filename_from_source "$s")

    if is_remote "$s"; then
      url=$(url_from_source "$s")
      fetch_url "$url" "$cache_dir"/"$filename" || return 1
      ln -sf "$cache_dir"/"$filename" "$target_dir"/ || return 1
    else
      ln -sf "$recipe_dir/$s" "$target_dir"/ || return 1
    fi
  done

  return 0
}


######################################################################
# Default 'fetch' implementation that simply takes the global, recipe-
# defined 'sources' variable and passes it to default_fetch.
#
# Globals:
#   $source_dir = the cache directory for downloaded sources
#   $sources    = defined sources array
#
# Arguments:
#   None
#
# Returns:
#   0 on success, 1 on failure
######################################################################
function fetch() {
  mkdir -p "$source_dir"
  default_fetch "$source_dir" "${sources[@]}" || return 1

  return 0
}


# TODO: document
function default_unpack() {
  declare -ar sources=("${@}")

  mkdir -p "$source_dir"

  info "Unpacking..."
  for u in "${sources[@]}"; do
    local fname dst
    fname=$(filename_from_source "$u")
    dst="$source_dir"/"$fname"

    case "$dst" in
      *.tar)
        info2 "Unpacking $fname..."
        tar -C "$source_dir" -xf "$dst" || return 1
        ;;
      *.tar.gz|*.tgz)
        info2 "Unpacking $fname..."
        tar -C "$source_dir" -zxf "$dst" || return 1
        ;;
      *.tar.bz2)
        info2 "Unpacking $fname..."
        tar -C "$source_dir" -jxf "$dst" || return 1
        ;;
      *.tar.lzma)
        info2 "Unpacking $fname..."
        unlzma -c "$dst" | tar -C "$source_dir" -x || return 1
        ;;
      *.tar.xz)
        info2 "Unpacking $fname..."
        unxz -c "$dst" | tar -C "$source_dir" -x || return 1
        ;;
      *.zip)
        info2 "Unpacking $fname..."
        unzip "$dst" -d "$source_dir" || return 1
        ;;
    esac
  done

  return 0
}


# TODO: document
function unpack() {
  default_unpack "${sources[@]}" || return 1

  return 0
}


######################################################################
# Starts the builds for the given recipe.
#
# Globals:
#   $base_dir   = the build directory
#   $recipe_dir = the recipe directory
#
# Arguments:
#   $1 = recipe name to build
#
# Returns:
#   0 on success, 1 on failure
######################################################################
function run_build() {
  local recipe_name="$1"

  local recipe_path="$recipe_dir"/"$recipe_name"
  if [[ ! -d "$recipe_path" ]]; then
    error "Recipe '$recipe_name' does not exist!"
    return 1
  fi
  if [[ ! -s "${recipe_path}/build.sh" ]]; then
    error "Recipe '$recipe_name' exists, but 'build.sh' is missing!"
    return 1
  fi

  # Make the source directory.
  local srcdir="$base_dir"/"$recipe_name"
  mkdir -p "$srcdir"

  # Run the remaining commands in a subshell.
  (
    # Set up variables.
    source_dir="$srcdir"
    setup_build_environment

    # Load the build script.
    debug "Recipe path = ${recipe_path}"
    source "$recipe_path/build.sh"

    # Build all dependencies.
    if [[ ${dependencies:-} ]]; then
      for dep in "${dependencies[@]}"; do
        echo "Would build dependency $dep"
      done
    fi

    # Run everything in order.
    fetch || exit 1
    unpack || exit 1

    info "Starting prepare()"
    prepare || exit 1

    info "Starting build()"
    build || exit 1

    if [[ "${binary:-}" == "true" ]]; then
      package || exit 1
    fi
    if [[ "${library:-}" == "true" ]]; then
      setup_env || exit 1
    fi

    info "Finished building: $recipe_name"
    exit 0
  )

  return $?
}


# TODO: document
function prepare() {
  # Do nothing by default
  debug "No prepare() function specified"
}


# TODO: document
function package() {
  warn "package() was called but not overridden"
}


# TODO: document
function setup_env() {
  warn "setup_env() was called but not overridden"

  # TODO: each dependency should create a file under
  # "$config_dir"/"$pkgname"/ENVIRONMENT_VAR that contains the value of that
  # flag that is required to compile using that dependency.
}


function setup_build_environment() {
  BBUILD_HOST_PLATFORM=$(uname | tr '[:upper:]' '[:lower:]')
  BBUILD_HOST_ARCH=$(uname -m | tr '[:upper:]' '[:lower:]')

  # TODO: figure me out properly from command line
  BBUILD_TARGET_PLATFORM=linux
  BBUILD_TARGET_ARCH=x86_64

  case "${BBUILD_TARGET_PLATFORM}-${BBUILD_TARGET_ARCH}" in
    linux-x86_64)
      BBUILD_CROSS_PREFIX=x86_64-linux-musl
      ;;
    linux-arm)
      BBUILD_CROSS_PREFIX=arm-linux-musleabihf
      ;;
    android-*)
      BBUILD_CROSS_PREFIX=arm-linux-musleabihf
      ;;
    darwin-x86_64)
      BBUILD_CROSS_PREFIX=x86_64-apple-darwin12
      ;;
    *)
      error "Cannot determine cross prefix for ${BBUILD_TARGET_PLATFORM}/${BBUILD_TARGET_ARCH}"
      return 1
  esac

  # Make everything readonly
  readonly BBUILD_HOST_PLATFORM BBUILD_HOST_ARCH
  readonly BBUILD_TARGET_PLATFORM BBUILD_TARGET_ARCH
  readonly BBUILD_CROSS_PREFIX

  # Set up build tools with prefixes
  export AR="${BBUILD_CROSS_PREFIX}-ar"
  export CC="${BBUILD_CROSS_PREFIX}-gcc"
  export CXX="${BBUILD_CROSS_PREFIX}-g++"
  export LD="${BBUILD_CROSS_PREFIX}-ld"
  export RANLIB="${BBUILD_CROSS_PREFIX}-ranlib"
  export STRIP="${BBUILD_CROSS_PREFIX}-strip"

  # Declare static flags
  BBUILD_STATIC_FLAGS=" -static "
  case "${BBUILD_TARGET_PLATFORM}-${BBUILD_TARGET_ARCH}" in
    darwin-*)
      BBUILD_STATIC_FLAGS=" -flto -O3 -mmacosx-version-min=10.6 "
      ;;
  esac
  readonly BBUILD_STATIC_FLAGS

  # Special-case for cross-compiling to darwin.
  if [[ "$BBUILD_TARGET_PLATFORM" = "darwin" ]]; then
    export CC="${BBUILD_CROSS_PREFIX}-clang"
    export CXX="${BBUILD_CROSS_PREFIX}-clang++"
    declare -xr OSXCROSS_NO_INCLUDE_PATH_WARNINGS=1
  fi
}


######################################################################
# Prints the usage for this script.
#
# Globals:
#   $base_dir   = the build directory
#   $recipe_dir = the recipe directory
#
# Arguments:
#   None
#
# Returns:
#   None
######################################################################
function usage() {
  echo "$program $program_version"
  cat <<EOF
usage: $program [options] <recipe(s)>

options:
  -b DIR    Set the build directory (default: $base_dir)
  -h        Print this help
  -m        Monochrome - disable colors.
  -q        Be more quiet
  -r DIR    Set the recipe directory (default: $recipe_dir)
  -v        Be more verbose
EOF
  exit 0
}


# Only proceed further if we aren't testing.
if [[ -n "${BBUILD_TESTING:-}" ]]; then
  # Don't exit, but just return.
  return 0
fi

# Disable colors if stderr isn't a terminal.
if [[ ! -t 2 ]]; then
  set_colors "off"
fi

# If our 'special' environment variable is set, it's an indicator that we
# should start the build for the given recipe.
if [[ -n "${BBUILD_BUILD_RECIPE:-}" ]]; then
  start_build "$1"
  exit $?
fi

# Default values of variables
base_dir=$(pwd)/build
recipe_dir=$(pwd)/recipes

# Parse arguments
while getopts ":b:hmqr:v" opt; do
  case $opt in
    b)
      base_dir="$OPTARG"
      ;;
    h)
      usage
      ;;
    m)
      set_colors "off"
      ;;
    q)
      verbosity=$(( verbosity + 1 ))
      ;;
    r)
      recipe_dir="$OPTARG"
      ;;
    v)
      verbosity=$(( verbosity - 1 ))
      ;;
    \?)
      error "Invalid option: -$OPTARG"
      exit 1
      ;;
    :)
      error "Option -$OPTARG requires an argument."
      exit 1
      ;;
  esac
done

# Remove all flags, just leaving our arguments.
shift $((OPTIND - 1))
debug "Flag parsing finished, have $# packages to build"

# Mark variables as read-only, and compute derived variables
readonly base_dir recipe_dir verbosity
declare -r cache_dir="$base_dir"/.cache

# SIGINT handling - print a nice message
trap 'die "Aborted by user"' INT

# Create necessary directories
for dir in "$base_dir" "$cache_dir"; do
  mkdir -p "$dir" || exit 1
done

# Actually build
for arg in "$@"; do
  info "Building: $arg"

  run_build "$arg"
  if [[ ! $? ]]; then
    debug "Recipe failed - exiting..."
    break
  fi
done


# vim: set tabstop=2 shiftwidth=2 textwidth=0 expandtab:
