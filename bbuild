#!/usr/bin/env bash


set -e              # Abort when a command exists with a non-zero exit status
set -o pipefail     # Cause a pipeline to return the exit status of the last
                    # command that returned a non-zero return value.
set -u              # Attempting to use an undefined variable will print an
                    # error and exit the program.


# Global script information.
program=${0##*/}
program_version=0.0.1
declare -i verbosity=2

# Color definitions (start as 'on').
NORMAL="\033[1;0m"
STRONG="\033[1;1m"
RED="\033[1;31m"
GREEN="\033[1;32m"
YELLOW="\033[1;33m"
BLUE="\033[1;34m"
MAGENTA="\033[1;35m"
WHITE="\033[1;37m"


######################################################################
# Enable / disable colors in the program.
#
# Globals:
#   None
#
# Arguments:
#   $1 = 'on' or 'off'
#
# Returns:
#   None
######################################################################
function set_colors() {
  case "$1" in
    on)
      NORMAL="\033[1;0m"
      STRONG="\033[1;1m"
      RED="\033[1;31m"
      GREEN="\033[1;32m"
      YELLOW="\033[1;33m"
      BLUE="\033[1;34m"
      MAGENTA="\033[1;35m"
      WHITE="\033[1;37m"
      ;;
    off)
      NORMAL=""
      STRONG=""
      RED=""
      GREEN=""
      YELLOW=""
      BLUE=""
      MAGENTA=""
      WHITE=""
      ;;
  esac
}


######################################################################
# Various helper log functions.
#
# Globals:
#   $verbosity = verboseness level
#
#   Note: verbosity levels
#       debug   = 1
#       info    = 2
#       warning = 3
#       error   = 4 (always printed)
#
# Arguments:
#   $1 = string
#
# Returns:
#   None
######################################################################
function debug() {
  [[ "$verbosity" -gt 1 ]] && return
  local prompt="${MAGENTA}==> DEBUG:${NORMAL}"
  printf "${prompt} ${WHITE}%s${NORMAL}\n" "$1" >&2
}

function info() {
  [[ "$verbosity" -gt 2 ]] && return
  local prompt="${GREEN}==>${NORMAL}"
  printf "${prompt} ${WHITE}%s${NORMAL}\n" "$1" >&2
}

function info2() {
  [[ "$verbosity" -gt 2 ]] && return
  local prompt="${BLUE}  ->${NORMAL}"
  printf "${prompt} ${WHITE}%s${NORMAL}\n" "$1" >&2
}

function warn() {
  [[ "$verbosity" -gt 3 ]] && return
  local prompt="${YELLOW}==> WARNING:${NORMAL}"
  printf "${prompt} ${WHITE}%s${NORMAL}\n" "$1" >&2
}

function error() {
  local prompt="${RED}==> ERROR:${NORMAL}"
  printf "${prompt} ${WHITE}%s${NORMAL}\n" "$1" >&2
}

function die() {
  error "$1"
  exit 1
}


######################################################################
# Fetches a given URL and saves it as the given file.
#
# Globals:
#   None
#
# Arguments:
#   $1 = url
#   $2 = target file
#
# Returns:
#   0 on success, 1 on failure
######################################################################
function fetch_url() {
  local url="$1"
  local target="$2"

  # TODO: options if verbose/not verbose
  # TODO: fall back to wget if curl not present
  curl -L -o "$target" "$url" || exit 1
  return 0
}


######################################################################
# Detects whether a given source is remote (i.e. whether the source
# is on the local filesystem or should be fetched from a remote
# location).
#
# Globals:
#   None
#
# Arguments:
#   $1 = source specification
#
# Returns:
#   0/true if the source is remote, 1/false if it is not
######################################################################
function is_remote() {
  local src="$1"

  case "${src#*::}" in
    http://*|ftp://*|https://*)
      return 0
      ;;
  esac

  return 1
}


######################################################################
# Gets the filename from a given source  If the source is prefixed
# with a 'filename::<url>', the 'filename' portion will be used
# instead of anything from the URL.
#
# Globals:
#   None
#
# Arguments:
#   $1 = source
#
# Returns:
#   0 always
#
# Stdout:
#   The filename from the given source
######################################################################
function filename_from_source() {
  local src="$1"

  # Get everything after the last slash.  Equivalent to $(basename $url).
  local filename="${src##*/}"

  # If there is a '::' in the source, we take everything before it.
  case "$src" in
    *::*) filename=${src%%::*};;
  esac

  # Output
  echo "$filename"
  return 0
}


######################################################################
# Gets the URL from a given source  If the source is prefixed with a
# 'filename::<url>', the 'filename' portion will be stripped.
#
# Globals:
#   None
#
# Arguments:
#   $1 = source
#
# Returns:
#   0 always
#
# Stdout:
#   The URL from the given source
######################################################################
function url_from_source() {
  local src="$1"
  local url="$src"

  # If there is a '::' in the source, we take everything after it.
  case "$src" in
    *::*) url=${src##*::};;
  esac

  # Output
  echo "$url"
  return 0
}


######################################################################
# Downloads all given sources into the specified target directory.
# Local file sources are symlinked into the target directory.
#
# Globals:
#   $recipe_dir = the recipe directory
#   $cache_dir  = the cache directory for downloaded sources
#
# Arguments:
#   $1 = sources
#   $2 = target directory
#
# Returns:
#   0 on success, 1 on failure
######################################################################
function default_fetch() {
  local sources="$1"
  local target_dir="$2"
  local filename url

  for s in $sources; do
    filename=$(filename_from_source "$s")

    if is_remote "$s"; then
      url=$(url_from_source "$s")
      fetch_url "$url" "$cache_dir"/"$filename" || return 1
      ln -sf "$cache_dir"/"$filename" "$target_dir"/
    else
      ln -sf "$recipe_dir/$s" "$target_dir"/
    fi
  done

  return 0
}


######################################################################
# Prints the usage for this script.
#
# Globals:
#   $build_base = the build directory
#   $recipe_dir = the recipe directory
#
# Arguments:
#   None
#
# Returns:
#   None
######################################################################
function usage() {
  echo "$program $program_version"
  cat <<EOF
usage: $program [options] <recipe(s)>

options:
  -b DIR    Set the build directory (default: $build_base)
  -h        Print this help
  -m        Monochrome - disable colors.
  -q        Be more quiet
  -r DIR    Set the recipe directory (default: $recipe_dir)
  -v        Be more verbose
EOF
  exit 0
}


# Only proceed further if we aren't testing.
if [[ -n "${BBUILD_TESTING:-}" ]]; then
  # Don't exit, but just return.
  return 0
fi

# Disable colors if stderr isn't a terminal.
if [[ ! -t 2 ]]; then
  set_colors "off"
fi

# Default values of variables
build_base=/tmp/build
recipe_dir=$(pwd)

# Parse arguments
while getopts ":b:hmqr:v" opt; do
  case $opt in
    b)
      build_base="$OPTARG"
      ;;
    h)
      usage
      ;;
    m)
      set_colors "off"
      ;;
    q)
      verbosity=$(( verbosity + 1 ))
      ;;
    r)
      recipe_dir="$OPTARG"
      ;;
    v)
      verbosity=$(( verbosity - 1 ))
      ;;
    \?)
      error "Invalid option: -$OPTARG"
      exit 1
      ;;
    :)
      error "Option -$OPTARG requires an argument."
      exit 1
      ;;
  esac
done

# Remove all flags, just leaving our arguments.
shift $((OPTIND - 1))
debug "Flag parsing finished, have $# packages to build"

# Compute derived variables
declare -r cache_dir="$build_base"/.cache

# Create necessary directories
for dir in "$build_base" "$cache_dir"; do
  mkdir -p "$dir" || exit 1
done

# Actually build
for arg in "$@"; do
  info "Building: $arg"
  info2 "Subargument"
done


# vim: set tabstop=2 shiftwidth=2 textwidth=0 expandtab:
